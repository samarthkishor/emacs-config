#+TITLE: GNU Emacs package configuration file
#+AUTHOR: Samarth Kishor

* macOS

  #+begin_src emacs-lisp
    (when (eq system-type 'darwin)
      (setq mac-option-modifier 'meta
	    mac-command-modifier 'control
	    mac-control-modifier 'super
	    mac-right-command-modifier 'super
	    mac-right-option-modifier 'none))

    (use-package exec-path-from-shell
      :if (memq window-system '(mac ns))
      :straight t
      :config
      (exec-path-from-shell-initialize))
  #+end_src
  
* =evil-mode=
  
  #+begin_src emacs-lisp
    (use-package evil
      :straight t
      :init
      (setq evil-want-integration nil)
      :config
      (defun prelude-shift-left-visual ()
        "Shift left and restore visual selection."
        (interactive)
        (evil-shift-left (region-beginning) (region-end))
        (evil-normal-state)
        (evil-visual-restore))
      (defun prelude-shift-right-visual ()
        "Shift right and restore visual selection."
        (interactive)
        (evil-shift-right (region-beginning) (region-end))
        (evil-normal-state)
        (evil-visual-restore))
      (setq evil-want-fine-undo t)
      (setq evil-shift-width 2)
      (setq evil-want-abbrev-expand-on-insert-exit nil)
      (define-key evil-visual-state-map (kbd ">") 'prelude-shift-right-visual)
      (define-key evil-visual-state-map (kbd "<") 'prelude-shift-left-visual)
      (evil-define-key nil evil-normal-state-map
        "j" 'evil-next-visual-line
        "k" 'evil-previous-visual-line)
      (evil-declare-key 'normal org-mode-map
        "gk" 'outline-up-heading
        "gj" 'outline-next-visible-heading
        (kbd "TAB") 'org-cycle
        "$" 'org-end-of-line ; smarter behavior on headlines etc.
        "^" 'org-beginning-of-line ; ditto
        "-" 'org-ctrl-c-minus ; change bullet style
        "<" 'org-metaleft ; out-dent
        ">" 'org-metaright) ; indent
      (evil-mode 1))
  #+end_src


  ;; good performance on long lines

  (use-package emacs
  :config
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t))

  (use-package so-long
  :config
  (global-so-long-mode 1))

  ;; Completions

* Theme
** General settings

   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq frame-title-format '("%b"))
       (setq echo-keystrokes 0.25)
       (setq default-input-method "greek")
       (setq ring-bell-function 'ignore)

       (defalias 'yes-or-no-p 'y-or-n-p)
       (put 'narrow-to-region 'disabled nil)
       (put 'upcase-region 'disabled nil)
       (put 'downcase-region 'disabled nil)
       (put 'dired-find-alternate-file 'disabled nil)
       (put 'overwrite-mode 'disabled t)
       (setq mode-require-final-newline 'visit-save))
   #+end_src

** Remove useless modeline indicators

   #+begin_src emacs-lisp
     (use-package diminish
       :straight t
       :after use-package)
   #+end_src

** Put customization settings in a separate file

   Source: [[https://gitlab.com/protesilaos/dotfiles/-/blob/master/emacs/.emacs.d/emacs-init.org][Prot's dotfiles]].

   When you install a package or use the various customisation interfaces
   to tweak things to your liking, Emacs will append a piece of Elisp to
   your init file.  In my experience, this is a common source of
   inconsistencies, arising from a conflict between the user’s code and
   what is stored in that added custom snippet.

   As such, I prefer to have all “custom” code stored in a separate,
   disposable file that I do not keep under version control.  When
   something does not seem to work as intended it is easy to edit
   =~/.emacs.d/custom.el= or outright delete it.

   #+begin_src emacs-lisp
     (use-package cus-edit
       :config
       (defvar prot/custom-file "~/.emacs.d/custom.el")

       (setq custom-file prot/custom-file)

       (defun prot/cus-edit ()
	 (let ((file prot/custom-file))
	   (unless (file-exists-p file)
	     (make-empty-file file))
	   (load-file file)))
       :hook (after-init-hook . prot/cus-edit))
   #+end_src

** Modus Themes

   Use Prot's Modus Themes with his configurations.

   #+begin_src emacs-lisp
     (use-package modus-themes
       :straight t
       :init
       (setq modus-themes-slanted-constructs t
	     modus-themes-bold-constructs t
	     modus-themes-fringes nil ; {nil,'subtle,'intense}
	     modus-themes-mode-line 'moody ; {nil,'3d,'moody}
	     modus-themes-syntax nil ; {nil,'faint,'yellow-comments,'green-strings,'yellow-comments-green-strings,'alt-syntax,'alt-syntax-yellow-comments}
	     modus-themes-intense-hl-line nil
	     modus-themes-paren-match 'subtle-bold ; {nil,'subtle-bold,'intense,'intense-bold}
	     modus-themes-links 'neutral-underline ; {nil,'faint,'neutral-underline,'faint-neutral-underline,'no-underline}
	     modus-themes-no-mixed-fonts nil
	     modus-themes-prompts nil ; {nil,'subtle,'intense}
	     modus-themes-completions nil ; {nil,'moderate,'opinionated}
	     modus-themes-region 'bg-only-no-extend ; {nil,'no-extend,'bg-only,'bg-only-no-extend}
	     modus-themes-diffs 'bg-only ; {nil,'desaturated,'fg-only,'bg-only}
	     modus-themes-org-blocks nil ; {nil,'grayscale,'rainbow}
	     modus-themes-headings ; Read the manual for this one
	     '((t . nil))
	     modus-themes-variable-pitch-headings nil
	     modus-themes-scale-headings nil
	     modus-themes-scale-1 1.1
	     modus-themes-scale-2 1.15
	     modus-themes-scale-3 1.21
	     modus-themes-scale-4 1.27
	     modus-themes-scale-5 1.33)
       :config
       ;; A simpler version of this is also in the manual.  The hook is
       ;; triggered by `modus-themes-toggle', `modus-themes-load-operandi',
       ;; `modus-themes-load-vivendi'.
       (defun prot/modus-themes-custom-faces ()
	 "Tweak faces after `modus-themes-after-load-theme-hook'."
	 (set-face-attribute 'cursor nil
			     :background (modus-themes-color-alts 'blue 'green-alt))
	 (set-face-attribute 'header-line nil :inherit 'variable-pitch)
	 (set-face-attribute 'tab-bar nil :inherit 'variable-pitch)
	 (set-face-attribute 'mode-line nil :inherit 'variable-pitch)
	 (set-face-attribute 'mode-line-inactive nil :inherit 'variable-pitch)
	 (set-face-attribute 'mode-line-buffer-id nil :weight 'normal)
	 (set-face-attribute 'line-number nil
			     :background 'unspecified
			     :foreground (modus-themes-color 'fg-unfocused))
	 (set-face-attribute 'line-number-current-line nil
			     :background 'unspecified
			     :foreground (modus-themes-color 'red-alt-other)))

       ;; Also check my package declaration for `prot-fonts' because I use
       ;; the `modus-themes-after-load-theme-hook' for some typeface-related
       ;; tweaks (as those are made at the "face" level).
       :hook ((after-init-hook . modus-themes-load-operandi)
	      (modus-themes-after-load-theme-hook . prot/modus-themes-custom-faces))
       :bind ("<f5>" . modus-themes-toggle))
   #+end_src

** Fonts

   Use Prot's font configurations.

   #+begin_src emacs-lisp
     (use-package prot-fonts
       :straight (:local-repo "prot-lisp")
       :after modus-themes                   ; Because I use its hook
       :init
       (setq prot-fonts-typeface-sets-alist
	     '((laptop . (150 "Hack" "DejaVu Sans Condensed"))
	       (desktop . (150 "Hack" "DejaVu Sans"))
	       (reader . (170 "Iosevka Comfy" "FiraGO"))
	       (presentation . (190 "Hack" "DejaVu Sans"))))
       (setq prot-fonts-monospaced-list
	     '("Hack" "DejaVu Sans Mono" "Iosevka Comfy" "Source Code Pro"
	       "Ubuntu Mono" "Fantasque Sans Mono" "Fira Code" "Monoid"))
       (setq prot-fonts-heights-list
	     '(100 105 110 120 130 140 150 160 170 180 190))
       (setq prot-fonts-line-spacing-alist
	     '(("Source Code Pro" . 1)
	       ("Ubuntu Mono" . 2)))
       (setq prot-fonts-laptop-desktop-keys-list '(laptop desktop))
       (setq prot-fonts-max-small-resolution-width 1366)
       (setq  prot-fonts-bold-weight-alist
	      '(("Iosevka Comfy" . semibold)
		("Source Code Pro" . semibold)))
       :config
       ;; This is defined in Emacs' C code, though I feel this is a good
       ;; place to put it.
       (setq x-underline-at-descent-line t)
       ;; And this just sets the right font depending on whether my laptop is
       ;; connected to an external monitor or not.
       (prot-fonts-fonts-per-monitor)
       :hook ((prot-fonts-set-typeface-hook . prot-fonts-line-spacing)
	      (prot-fonts-set-typeface-hook . prot-fonts-bold-face)
	      ;; See theme section for this hook
	      (modus-themes-after-load-theme-hook . prot-fonts-bold-face))
       :bind ("C-c f" . prot-fonts-set-fonts-dwim))
   #+end_src
   
** Focused Editing

   These settings (once again taken from Prot's config) enable a great reading experience for prose inside of Emacs.

   #+begin_src emacs-lisp
     (use-package face-remap :diminish buffer-face-mode)

     (use-package olivetti
       :straight t
       :diminish
       :config
       (setq olivetti-body-width 0.7)
       (setq olivetti-minimum-body-width 80)
       (setq olivetti-recall-visual-line-mode-entry-state t))

     (use-package prot-logos
       :straight (:type built-in)
       :diminish visual-line-mode
       :config
       (setq prot-logos-org-presentation nil)
       (setq prot-logos-scroll-lock nil)
       (setq prot-logos-hidden-modeline nil)
       :bind ("<f9>" . prot-logos-focus-mode))
   #+end_src

** Mode line

   Use the default modeline for speed even though it's a bit ugly.

   Heavily inspired by [[github.com/jamesnvc/dotfiles/blob/master/emacs.d/modules/cogent-modeline.el][cogent-modeline]] and Prot's configuration.

   #+begin_src emacs-lisp
     (use-package emacs
       :init
       (setq mode-line-percent-position '(-3 "%p"))
       (setq mode-line-position-column-line-format '(" %l,%c")) ; Emacs 28
       (setq mode-line-defining-kbd-macro
             (propertize " Macro" 'face 'mode-line-emphasis))

       (setq-default mode-line-format
                     (list
                      '(:eval (propertize (if (eq 'emacs evil-state) "  " "  ")))

                      " "

                      '(:eval (list
                               ;; the buffer name; the file name as a tool tip
                               " "
                               (propertize "%b"
                                           'help-echo (buffer-file-name))
                               (when (buffer-modified-p)
                                 (propertize
                                  " "))
                               (when buffer-read-only
                                 (propertize
                                  ""))
                               " "))

                      ;; relative position in file: (line, column) percent
                      '(:propertize " (%l, %c)" 'face 'font-lock-constant-face)
                      '(:propertize " %p" 'face 'font-lock-constant-face)

                      '(pdf-misc-size-indication-minor-mode
                        (:eval (let* ((page (pdf-view-current-page))
                                      (pdf-page (nth (1- page) (pdf-cache-pagelabels))))
                                 (list
                                  " "
                                  (when (not (string= (number-to-string page) pdf-page))
                                    (list "(" pdf-page ") "))
                                  (number-to-string (pdf-view-current-page))
                                  "/"
                                  (number-to-string (pdf-cache-number-of-pages))))))

                      "     "
                      mode-line-misc-info ;; time & date
                      "     "

                      '(vc-mode vc-mode)

                      ;; spaces to align right
                      '(:eval (propertize
                               " " 'display
                               `((space :align-to (- (+ right right-fringe right-margin)
                                                     ,(+ 3 (string-width
                                                            (if (listp mode-name)
                                                                (car mode-name)
                                                              mode-name))))))))

                      ;; the current major mode
                      '(:propertize " %m " 'face 'font-lock-string-face))))

     ;; Include the time in the mode-line
     (use-package time
       :commands world-clock
       :config
       (setq display-time-format "%H:%M  %m/%d/%Y")
       ;;;; Covered by `display-time-format'
       ;; (setq display-time-24hr-format t)
       ;; (setq display-time-day-and-date t)
       (setq display-time-interval 60)
       (setq display-time-mail-directory nil)
       (setq display-time-default-load-average nil)

       ;;; World clock
       (setq zoneinfo-style-world-list
             '(("America/Los_Angeles" "Los Angeles")
               ("America/New_York" "New York")
               ("Europe/Brussels" "Brussels")
               ("Asia/Shanghai" "Shanghai")
               ("Asia/Tokyo" "Tokyo")))

       ;; All of the following variables are for Emacs 28
       (setq world-clock-list t)
       (setq world-clock-time-format "%R %z  %A %d %B")
       (setq world-clock-buffer-name "*world-clock*") ; Placement handled by
                                             ; `display-buffer-alist'
       (setq world-clock-timer-enable t)
       (setq world-clock-timer-second 60)

       :hook (after-init-hook . display-time-mode))
   #+end_src

   #+begin_src emacs-lisp
   (use-package moody
     :straight t
     :after (prot-fonts             ; we need its hook
             prot-simple)           ; provides `prot-simple--number-even-p'
     :config
     (moody-replace-mode-line-buffer-identification)
     (moody-replace-vc-mode)
     (setq x-underline-at-descent-line t)

     (defun prot/moody--height ()
       "Set Moody height to an even number.
   Bind this to a hook that gets called after loading/changing the
   mode line's typeface (or the default one if they are the same)."
       (let* ((font (face-font 'mode-line))
              (height (truncate (* 2 (aref (font-info font) 2))))
              (height-even (if (prot-common-number-even-p height) height (+ height 1))))
         (if font
             height-even
           24)))
           
     (defun prot/moody--mode-line-height ()
       "Set Moody height to the value of `prot/moody--height'."
       (setq moody-mode-line-height (funcall 'prot/moody--height)))

     :hook (prot-fonts-set-typeface-hook . prot/moody--mode-line-height))
   #+end_src
  

   Use the mode line to show the keys being pressed and the command they call.

   #+begin_src emacs-lisp
     (use-package keycast
       :straight t
       :after moody
       :commands keycast-mode
       :config
       (setq keycast-window-predicate 'moody-window-active-p)
       (setq keycast-separator-width 1)
       (setq keycast-insert-after 'mode-line-buffer-identification)
       (setq keycast-remove-tail-elements nil)

       (dolist (input '(self-insert-command
            org-self-insert-command))
     (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

       ;;; TODO identify all events that should be excluded
       ;; mouse-set-point
       ;; mouse-set-region
       ;; mouse-drag-secondary
       ;; mouse-drag-line
       ;; mouse-drag-drag
       ;; mouse-start-end
       ;; mouse-drag-region nil
       ;; mouse-drag-track nil
       ;; mouse-drag-region-rectangle
       ;; mouse-drag-and-drop-region
       ;; mwheel-event-button
       ;; dframe-mouse-event-p
       ;; mouse-drag-events-are-point-events-p

       (dolist (event '(mouse-event-p
            mouse-movement-p
            mwheel-scroll))
     (add-to-list 'keycast-substitute-alist `(,event nil))))
   #+end_src

** Window borders

   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (when window-system (scroll-bar-mode -1))
       (tool-bar-mode 0)
       (if (eq window-system 'ns)
           (toggle-frame-maximized)
         (toggle-frame-fullscreen))
       (setq window-divider-default-right-width 1)
       (setq window-divider-default-bottom-width 1)
       (setq window-divider-default-places 'right-only)
       :hook (after-init-hook . window-divider-mode))
   #+end_src

** Fringe

   #+begin_src emacs-lisp
     (use-package fringe
       :config
       (fringe-mode nil)
       (setq-default fringes-outside-margins nil)
       (setq-default indicate-buffer-boundaries nil)
       (setq-default indicate-empty-lines nil)
       (setq-default overflow-newline-into-fringe t))
   #+end_src
   
   Highlight changes to the current buffer.

   #+begin_src emacs-lisp
     (use-package diff-hl
       :straight t
       :after vc
       :config
       (setq diff-hl-draw-borders nil)
       (setq diff-hl-side 'left)
       :hook (after-init-hook . global-diff-hl-mode))
   #+end_src

* Performance
** Garbage collection 

   Increase GC threshold on startup for faster load times.

   #+begin_src emacs-lisp
     (defvar file-name-handler-alist-backup
             file-name-handler-alist)

     (setq gc-cons-threshold most-positive-fixnum
           file-name-handler-alist nil)

     (add-hook 'after-init-hook
       (lambda ()
         (garbage-collect)
         (setq gc-cons-threshold
                 (car (get 'gc-cons-threshold 'standard-value))
           file-name-handler-alist
             (append
               file-name-handler-alist-backup
               file-name-handler-alist))))
   #+end_src

** Long lines

   Increase performance for larger files.

   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq-default bidi-paragraph-direction 'left-to-right)
       (setq bidi-inhibit-bpa t))

     (use-package so-long
       :config
       (global-so-long-mode 1))
   #+end_src

* Completion

  Source: [[https://gitlab.com/protesilaos/dotfiles/-/blob/master/emacs/.emacs.d/emacs-init.org][Prot's dotfiles]].
   
** Fuzzy Completion

   #+begin_quote
   It provides the =orderless= completion style for
   efficient out-of-order grouped pattern matching.  The components can be
   determined using several styles, such as regexp, flex, prefix,
   initialism (check its README because there are lots of variations).
   Delimiters are literal spaces by default, but can be configured to match
   other characters, with hyphens and slashes being likely choices.  As
   such, Orderless can supersede---and for most cases improve upon---the
   completion styles that come built into Emacs, adding to them the
   powerful out-of-order capability.

   The =prot-orderless.el= contains the few tweaks I introduce (full code
   further below).  In particular, it defines two style dispatchers.  Those
   are single characters that acquire a special meaning while at the end of
   a given input.  With the equals sign appended to a sequence of
   characters, we call =prot-orderless-literal-dispatcher= which instructs
   orderless to match that sequence as a literal string.  While a comma
   reads it as an initialism, per =prot-orderless-initialism-dispatcher=.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package prot-orderless
       :straight (:type built-in)
       :demand)

     (use-package orderless
       :straight t
       :demand
       :after prot-orderless
       :config
       (setq orderless-component-separator " +")
       (setq orderless-matching-styles
         '(orderless-flex
           orderless-strict-leading-initialism
           orderless-regexp
           orderless-prefixes
           orderless-literal))
       (setq orderless-style-dispatchers
         '(prot-orderless-literal-dispatcher
           prot-orderless-initialism-dispatcher))
       ;; SPC should never complete: use it for `orderless' groups.
       :bind (:map minibuffer-local-completion-map
           ("SPC" . nil)))
   #+end_src

** Minibuffer completion

   #+begin_quote
   The code block below is specifically about the minibuffer setup.  *This
   does not cover the visualisation of completion candidates*, which is
   handled by Icomplete---those are defined in the next section about
   [[#h:b6b13f4f-91f5-416d-9934-b51b4d87770c][Icomplete configurations and extras]].

   Here is an overview of the settings covered herein:

   + Completion styles :: I mostly rely on [[#h:7b1374dd-6b1f-4548-8fbf-1034230c80e0][the Orderless completion style]].
     An exception is a niche functionality of the =partial-completion= style
     (built-in): with it you can navigate to a filesystem path like
     =~/.l/s/fo= for =~/.local/share/fonts=.  So my recommendation is to use
     those two styles to cover every case.

   + Recursive minibuffers :: I enable recursive minibuffers.  This
     practically means that you can start something in the minibuffer,
     switch to another window, call the minibuffer again, run some
     commands, and then move back to what you initiated in the original
     minibuffer.  To exit, hit =C-]= (=abort-recursive-edit=), though the
     regular =C-g= should also do the trick.

     The =minibuffer-depth-indicate-mode= will show a depth indicator,
     represented as a number, next to the minibuffer prompt, if a recursive
     edit is in progress.

   + Key bindings :: Note the nuances in the behaviour between =RET= and =C-j=.
     With the Return key, we instruct the minibuffer to expand the current
     candidate and then exit the session, if possible.  Whereas =C-j= is
     meant to insert the minibuffer's contents exactly as they are and exit
     immediately.  You need the latter in cases where you want =foo= but the
     match is for =foobar=.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package prot-minibuffer
       :straight (:type built-in)
       :demand
       :bind (("M-X" . prot-minibuffer-mode-commands)
          ("s-v" . prot-minibuffer-focus-mini-or-completions)
          :map completion-list-mode-map
          ("M-v" . prot-minibuffer-focus-mini)
          ("h" . prot-simple-describe-symbol) ; from `prot-simple.el'
          ;; Those are generic actions for the "*Completions*" buffer.  I
          ;; normally use `embark' and its own buffers.
          ("w" . prot-minibuffer-completions-kill-symbol-at-point)
          ("i" . prot-minibuffer-completions-insert-symbol-at-point)
          ("j" . prot-minibuffer-completions-insert-symbol-at-point-exit))
       :hook (minibuffer-setup-hook . prot-minibuffer-mini-cursor))

     (use-package minibuffer
       :demand
       :after prot-minibuffer
       :config
       (setq completion-styles '(orderless partial-completion))
       (setq completion-category-defaults nil)
       (setq completion-cycle-threshold 3)
       (setq completion-flex-nospace nil)
       (setq completion-pcm-complete-word-inserts-delimiters t)
       (setq completion-pcm-word-delimiters "-_./:| ")
       (setq completion-show-help nil)
       (setq completion-ignore-case t)

       ;; The following two are updated in Emacs 28.  They concern the
       ;; *Completions* buffer.
       (setq completions-format 'one-column)
       (setq completions-detailed t)

       (setq read-buffer-completion-ignore-case t)
       (setq read-file-name-completion-ignore-case t)

       (setq enable-recursive-minibuffers t)
       (setq read-answer-short t)
       (setq resize-mini-windows t)
       (setq minibuffer-eldef-shorten-default t)

       (file-name-shadow-mode 1)
       (minibuffer-depth-indicate-mode 1)
       (minibuffer-electric-default-mode 1)

       ;; Defines, among others, aliases for common minibuffer commands to
       ;; Super-KEY.  Normally these should go in individual package
       ;; declarations, but their grouping here makes things easier to
       ;; understand.  Besides, they are related to the minibuffer.
       :bind (("s-b" . switch-to-buffer)
          ("s-B" . switch-to-buffer-other-window)
          ("s-f" . find-file)
          ("s-F" . find-file-other-window)
          ("s-d" . dired)
          ("s-D" . dired-other-window)
          :map minibuffer-local-completion-map
          ("<return>" . minibuffer-force-complete-and-exit) ; exit with completion
          ("C-j" . exit-minibuffer)      ; force input unconditionally
          :map completion-list-mode-map
          ("n" . next-line)
          ("p" . previous-line)
          ("f" . next-completion)
          ("b" . previous-completion)))
   #+end_src

** Icomplete configuration

   #+begin_quote
   The following package declaration is for the built-in interactive
   minibuffer-based completion interface: =icomplete=.  Remember that the
   underlying completion mechanisms are handled by the minibuffer
   itself
   #+end_quote
 
   #+begin_src emacs-lisp
     (use-package prot-icomplete
       :straight (:type built-in)
       :demand
       :config
       ;; Only use this if you do not want `embark'
       (prot-icomplete-actions -1)

       ;; Hooks' syntax is controlled by the `use-package-hook-name-suffix'
       ;; variable.  The "-hook" suffix is intentional.
       :hook (icomplete-minibuffer-setup-hook . prot-icomplete-truncate))

     (use-package icomplete
       :demand
       :after prot-minibuffer
       :config
       (setq icomplete-delay-completions-threshold 100)
       (setq icomplete-max-delay-chars 2)
       (setq icomplete-compute-delay 0.2)
       (setq icomplete-show-matches-on-no-input t)
       (setq icomplete-hide-common-prefix nil)
       (setq icomplete-prospects-height 1)
       (setq icomplete-separator (propertize " · " 'face 'shadow))
       ;; (setq icomplete-separator " │ ")
       ;; (setq icomplete-separator " ┆ ")
       ;; (setq icomplete-separator " ¦ ")
       ;; (setq icomplete-separator " ┆ ")
       (setq icomplete-with-completion-tables t)
       (setq icomplete-tidy-shadowed-file-names t)

       (fido-mode -1)                        ; Emacs 27.1
       (icomplete-mode 1)

       :bind (:map icomplete-minibuffer-map
           ("C-," . nil)             ; disable defaults
           ("C-." . nil)             ; same
           ("<tab>" . icomplete-force-complete)
           ("<return>" . icomplete-force-complete-and-exit) ; exit with completion
           ("C-j" . exit-minibuffer) ; force input unconditionally
           ("C-n" . icomplete-forward-completions)
           ("<right>" . icomplete-forward-completions)
           ("<down>" . icomplete-forward-completions)
           ("C-p" . icomplete-backward-completions)
           ("<left>" . icomplete-backward-completions)
           ("<up>" . icomplete-backward-completions)
           ;; The following command is from Emacs 27.1
           ("<C-backspace>" . icomplete-fido-backward-updir)))
   #+end_src

** Vertical completion

   #+begin_quote
   Icomplete displays its list horizontally by default.  This is how I like
   it for many cases, because the candidates are often short and I do not
   want to have the window layout undergo any mutations in size as the
   minibuffer expands and contracts.  A horizontal, one-line-tall Icomplete
   is okay.

   There are, however, cases where verticality provides a genuine usability
   boost: when the candidates are naturally long.  To that end I set the
   helper function =icomplete-vertical-toggle= to a convenient key binding
   inside the minibuffer.  I invoke the toggle whenever the need arises.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package icomplete-vertical
       :straight (:host github :repo "oantolin/icomplete-vertical" :branch "master")
       :after (minibuffer icomplete)
       :config
       (setq icomplete-vertical-prospects-height (/ (frame-height) 6))
       (icomplete-vertical-mode -1)
       :bind (:map icomplete-minibuffer-map
           ("C-v" . icomplete-vertical-toggle)))
   #+end_src
** Completion annotations

   #+begin_quote
   This is a utility jointly developed by Daniel Mendler and Omar Antolín
   Camarena that provides annotations to completion candidates.  It is
   meant to be a framework-agnostic tool, so it works nicely with Consult,
   Icomplete vertical, and Embark.
   #+end_quote
    
   #+begin_src emacs-lisp
     (use-package marginalia
       :straight (:host github :repo "minad/marginalia" :branch "main")
       :demand
       :config
       (marginalia-mode)
       (setq marginalia-annotators '(marginalia-annotators-heavy
                     marginalia-annotators-light))
       :bind (:map minibuffer-local-completion-map
           ("C-i" . marginalia-cycle-annotators)))
   #+end_src
** Enhanced minibuffer commands

   #+begin_quote
   Daniel Mendler's Consult is a new entry to the ecosystem of small,
   modular tools that work with the standard Emacs completion framework.
   It provides enhanced versions of several common commands, like
   =switch-to-buffer=, while it offers useful functionality, such as the
   ability to visualise---and revisit---items in the mark ring.

   While this section in a work-in-progress, note that my =prot-consult.el=
   defines some quick and dirty extensions that add minor visual feedback
   to the various jump actions that Consult makes possible.
   #+end_quote

   #+begin_src emacs-lisp
     ;; TODO: configure pattern-matching on a per-command basis
     (use-package consult
       :straight (:host github :repo "minad/consult" :branch "master")
       :config
       (setq consult-line-numbers-widen t)
       (setq consult-preview-buffer nil)
       (setq consult-preview-mark t)
       (setq consult-preview-line t)
       (setq consult-preview-outline nil)
       (setq completion-in-region-function #'consult-completion-in-region)
       (consult-preview-mode 1)
       :bind (("M-s s" . consult-outline)
          ("M-s M-s" . consult-outline)
          ("M-s m" . consult-mark)
          ("M-s l" . consult-line)
          ("M-s M-." . consult-line-symbol-at-point)
          :map minibuffer-local-completion-map
          ("<tab>" . minibuffer-force-complete)))

     (use-package prot-consult
       :straight (:type built-in)
       :after prot-pulse
       :config
       (setq prot-consult-add-advice-set-hooks t)
       (setq prot-consult-command-centre-list '(consult-line consult-mark))
       (setq prot-consult-command-top-list '(consult-outline))

       (prot-consult-set-up-hooks-mode 1))
   #+end_src
** Key command completion
   
   Use =which-key= to offer suggestions for completing a command.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :straight t
       :diminish which-key-mode
       :init
       (which-key-mode))
   #+END_SRC
** Code completion

    Company is a solid code completion engine for Emacs. =C-M-i= brings up completions.
    
    Source: [[https://matthewbauer.us/bauer/#install][Bauer's Emacs]]

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :straight t
        :init
        (setq company-minimum-prefix-length 2
              company-tooltip-limit 14
              company-dabbrev-downcase nil
              company-dabbrev-ignore-case nil
              company-dabbrev-code-other-buffers t
              company-tooltip-align-annotations t
              company-require-match 'never
              company-global-modes
              '(not erc-mode message-mode help-mode gud-mode eshell-mode)
              company-backends '(company-capf)
              company-frontends
              '(company-pseudo-tooltip-frontend
                company-echo-metadata-frontend))
        :preface
        (load "company-autoloads" t t)
        (defun company-complete-common-or-cycle-backward ()
          "Complete common prefix or cycle backward."
          (interactive)
          (company-complete-common-or-cycle -1))
        :bind (:map company-mode-map
                    ("C-M-i" . company-complete-common-or-cycle)
                    :map company-active-map
                    ("RET" . company-complete-selection)
                    ([return] . company-complete-selection)
                    ("C-j" . company-complete-selection)

                    ("TAB" . company-complete-common-or-cycle)
                    ("<tab>" . company-complete-common-or-cycle)
                    ("S-TAB" . company-complete-common-or-cycle-backward)
                    ("<backtab>" . company-complete-common-or-cycle-backward)
                    ("C-n" . company-select-next)
                    ("C-p" . company-select-previous)

                    ("C-/" . company-search-candidates)
                    ("C-M-/" . company-filter-candidates)
                    ("C-d" . company-show-doc-buffer))
        :hook ((prog-mode . company-mode)
               (shell-mode . (lambda ()
                               (setq-local company-backends '(company-capf))))
               (eshell-mode . (lambda () (setq-local company-backends '(company-files)))))
        :config
        (advice-add 'completion-at-point
                    :around (lambda (old-function &rest args)
                              (if company-mode
                                  (apply 'company-complete-common-or-cycle args)
                                (apply old-function args)))))

    #+END_SRC

** Imenu

   #+begin_quote
   =imenu.el= is a built-in library that constructs an index of buffer
   positions pointing to semantically relevant constructs.  With =M-x imenu=
   it displays the list through a completion interface.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package imenu
       :config
       (setq imenu-use-markers t)
       (setq imenu-auto-rescan t)
       (setq imenu-auto-rescan-maxout 600000)
       (setq imenu-max-item-length 100)
       (setq imenu-use-popup-menu nil)
       (setq imenu-eager-completion-buffer t)
       (setq imenu-space-replacement " ")
       (setq imenu-level-separator "/")
       :after prot-pulse
       :hook ((imenu-after-jump-hook . prot-pulse-recentre-top)
          (imenu-after-jump-hook . prot-pulse-show-entry)))
   #+end_src

   #+begin_quote
   This package offers a global and a local minor mode for flattening the
   index of =imenu=.  By default Imenu produces a multi-level index, where
   appropriate.

   By enabling the =flimenu-global-mode= we get a flat list for the
   completion-based interaction with =imenu=.  Now we can just search
   directly for any item on the list.

   To make things even better, we can still access the fully fledged tree
   presentation of =imenu-list=, as it operates independently.
   #+end_quote


   #+begin_src emacs-lisp
     (use-package flimenu
       :straight t
       :after imenu
       :config
       (flimenu-global-mode 1))
   #+end_src

** Projects

   I guess there's no longer any need to use Projectile...

   #+begin_src emacs-lisp
     (use-package project
       :demand
       :init
       (setq project-switch-commands
         '((?f "File" project-find-file)
           (?s "Subdir" prot-project-find-subdir)
           (?g "Grep" project-find-regexp)
           (?d "Dired" project-dired)
           (?b "Buffer" project-switch-to-buffer)
           (?q "Query replace" project-query-replace-regexp)
           (?t "Tag switch" prot-project-retrieve-tag)
           (?m "Magit" prot-project-magit-status)
           (?v "VC dir" project-vc-dir)
           (?l "Log VC" prot-project-commit-log)
           (?e "Eshell" project-eshell)))
       :bind ("C-x p q" . project-query-replace-regexp)) ; C-x p is `project-prefix-map'

     (use-package prot-project
       :straight (:type built-in)
       :demand
       :init
       (setq prot-project-project-roots '("~/Git/Projects/" "~/Git/build/"))
       (setq prot-project-commit-log-limit 25)
       (setq prot-project-large-file-lines 1000)
       :bind (("C-x p <delete>" . prot-project-remove-project)
          ("C-x p l" . prot-project-commit-log)
          ("C-x p m" . prot-project-magit-status)
          ("C-x p s" . prot-project-find-subdir)
          ("C-x p t" . prot-project-retrieve-tag)))
   #+end_src
** Recent Files
    
   #+begin_src emacs-lisp
     (use-package recentf
       :config
       (setq recentf-save-file "~/.emacs.d/recentf")
       (setq recentf-max-saved-items 200)
       (setq recentf-exclude '(".gz" ".xz" ".zip" "/elpa/" "/ssh:" "/sudo:"))
       :hook (after-init-hook . recentf-mode))
   #+end_src

** Isearch
    
   #+begin_src emacs-lisp
     (use-package isearch
       :diminish
       :config
       (setq search-highlight t)
       (setq search-whitespace-regexp ".*?")
       (setq isearch-lax-whitespace t)
       (setq isearch-regexp-lax-whitespace nil)
       (setq isearch-lazy-highlight t)
       ;; All of the following variables were introduced in Emacs 27.1.
       (setq isearch-lazy-count t)
       (setq lazy-count-prefix-format nil)
       (setq lazy-count-suffix-format " (%s/%s)")
       (setq isearch-yank-on-move 'shift)
       (setq isearch-allow-scroll 'unlimited)
       :bind (:map minibuffer-local-isearch-map
          ("M-/" . isearch-complete-edit)
          :map isearch-mode-map
          ("C-g" . isearch-cancel)       ; instead of `isearch-abort'
          ("M-/" . isearch-complete)))
   #+end_src

** Ripgrep for faster completions

   #+begin_src emacs-lisp
     (use-package rg
       :straight t
       :config
       (setq rg-group-result t)
       (setq rg-hide-command t)
       (setq rg-show-columns nil)
       (setq rg-show-header t)
       (setq rg-custom-type-aliases nil)
       (setq rg-default-alias-fallback "all")

       (rg-define-search prot/rg-vc-or-dir
     "RipGrep in project root or present directory."
     :query ask
     :format regexp
     :files "everything"
     :dir (or (vc-root-dir)              ; search root project dir
          default-directory)         ; or from the current dir
     :confirm prefix
     :flags ("--hidden -g !.git"))

       (rg-define-search prot/rg-ref-in-dir
     "RipGrep for thing at point in present directory."
     :query point
     :format regexp
     :files "everything"
     :dir default-directory
     :confirm prefix
     :flags ("--hidden -g !.git"))

       (defun prot/rg-save-search-as-name ()
     "Save `rg' buffer, naming it after the current search query.

     This function is meant to be mapped to a key in `rg-mode-map'."
     (interactive)
     (let ((pattern (car rg-pattern-history)))
       (rg-save-search-as-name (concat "«" pattern "»"))))

       :bind (("M-s g" . prot/rg-vc-or-dir)
          ("M-s r" . prot/rg-ref-in-dir)
          :map rg-mode-map
          ("s" . prot/rg-save-search-as-name)
          ("C-n" . next-line)
          ("C-p" . previous-line)
          ("M-n" . rg-next-file)
          ("M-p" . rg-prev-file)))
   #+end_src
    
** Cross-references

   #+begin_quote
   Xref provides helpful commands for code navigation and discovery, such
   as =xref-find-definitions= (=M-.=) and its counterpart
   =xref-pop-marker-stack= (=M-,=).
   #+end_quote

   #+begin_src emacs-lisp
     (use-package xref
       :config
       (setq xref-show-definitions-function #'xref--show-defs-minibuffer)
       (setq xref-search-program 'ripgrep))  ; Emacs 28
   #+end_src
* Buffers
  
  Source: [[https://gitlab.com/protesilaos/dotfiles/-/blob/master/emacs/.emacs.d/emacs-init.org][Prot's dotfiles]].

** Ibuffer

   #+begin_src emacs-lisp
     (use-package ibuffer
       :config
       (setq ibuffer-expert t)
       (setq ibuffer-display-summary nil)
       (setq ibuffer-use-other-window nil)
       (setq ibuffer-show-empty-filter-groups nil)
       (setq ibuffer-movement-cycle nil)
       (setq ibuffer-default-sorting-mode 'filename/process)
       (setq ibuffer-use-header-line t)
       (setq ibuffer-default-shrink-to-minimum-size nil)
       (setq ibuffer-formats
         '((mark modified read-only locked " "
             (name 30 30 :left :elide)
             " "
             (size 9 -1 :right)
             " "
             (mode 16 16 :left :elide)
             " " filename-and-process)
           (mark " "
             (name 16 -1)
             " " filename)))
       (setq ibuffer-saved-filter-groups nil)
       (setq ibuffer-old-time 48)
       :hook (ibuffer-mode-hook . hl-line-mode)
       :bind (("C-x C-b" . ibuffer)
          :map ibuffer-mode-map
          ("* f" . ibuffer-mark-by-file-name-regexp)
          ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
          ("* n" . ibuffer-mark-by-name-regexp)
          ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
          ("/ g" . ibuffer-filter-by-content)))

     (use-package prot-ibuffer
       :straight (:type built-in)
       :bind (("M-s b" . prot-ibuffer-buffers-major-mode)
          ("M-s v" . prot-ibuffer-buffers-vc-root)))
   #+end_src

** Scratch buffers

   #+begin_quote
   This package will produce a buffer that matches the major mode of the
   one you are currently in.  Use it with M-x scratch.  Doing that with a
   prefix argument (C-u) will prompt for a major mode instead.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package scratch
       :straight t
       :config
       (defun prot/scratch-buffer-setup ()
       "Add contents to `scratch' buffer and name it accordingly.
     If region is active, add its contents to the new buffer."
       (let* ((mode major-mode)
          (string (format "Scratch buffer for: %s\n\n" mode))
          (region (with-current-buffer (current-buffer)
              (if (region-active-p)
                  (buffer-substring-no-properties
                   (region-beginning)
                   (region-end)))
              ""))
          (text (concat string region)))
     (when scratch-buffer
       (save-excursion
         (insert text)
         (goto-char (point-min))
         (comment-region (point-at-bol) (point-at-eol)))
       (forward-line 2))
     (rename-buffer (format "*Scratch for %s*" mode) t)))
       :hook (scratch-create-buffer-hook . prot/scratch-buffer-setup)
       :bind ("C-c s" . scratch))
   #+end_src

** Tabs

   #+begin_quote
   All settings I configure here are meant to work in accordance with this
   abstract conception of "tabs are work spaces".  Here are the main key
   chords for =tab-bar= (they will all work properly if you keep the mode
   active):
   #+end_quote


   | Key     | Description                       |
   |---------+-----------------------------------|
   | C-x t b | Open a buffer in a new tab        |
   | C-x t d | Open a directory in a new tab     |
   | C-x t f | Open a file in a new tab          |
   | C-x t 0 | Close current tab                 |
   | C-x t 1 | Close all other tabs              |
   | C-x t 2 | Open current buffer in new tab    |
   
   #+begin_src emacs-lisp
     (use-package tab-bar
       :init
       (setq tab-bar-close-button-show nil)
       (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
       (setq tab-bar-close-tab-select 'recent)
       (setq tab-bar-new-tab-choice t)
       (setq tab-bar-new-tab-to 'right)
       (setq tab-bar-position nil)
       (setq tab-bar-show nil)
       (setq tab-bar-tab-hints nil)
       (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)
       :config
       (tab-bar-mode -1)
       (tab-bar-history-mode -1)
       :bind (("<s-tab>" . tab-next)
          ("<S-s-tab>" . tab-previous)))

     (use-package prot-tab
       :straight (:type built-in)
       :after tab-bar
       :bind (("<f8>" . prot-tab-tab-bar-toggle)
          ("C-x t t" . prot-tab-select-tab-dwim)
          ("s-t" . prot-tab-select-tab-dwim)))
   #+end_src

** Highlight Annotations
   
   #+begin_src emacs-lisp
     (use-package hl-todo
       :straight t
       :hook (prog-mode-hook . hl-todo-mode))
   #+end_src

** Backups

   Backup files/buffers in a separate directory.

   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq backup-directory-alist
             '(("." . "~/.emacs.d/backup/")))
       (setq backup-by-copying t)
       (setq version-control t)
       (setq delete-old-versions t)
       (setq kept-new-versions 6)
       (setq kept-old-versions 2)
       (setq create-lockfiles nil))
   #+end_src

* Programming
** Editing
   
   #+begin_src emacs-lisp
     (use-package paren
       :config
       (setq show-paren-style 'parenthesis)
       :hook (after-init-hook . show-paren-mode))
   #+end_src
   
   Change the color of delimiters in programming modes.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :straight t
       :config
       (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
   #+END_SRC

   
   Use =smartparens= as a =paredit= alternative.

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :straight t
       :diminish
       :init
       (require 'smartparens-config)
       (smartparens-global-mode 1)
       (sp-use-paredit-bindings)
       :config
       (defun my-create-newline-and-enter-sexp (&rest _ignored)
         "Open a new brace or bracket expression, with relevant newlines and indent. "
         (newline)
         (indent-according-to-mode)
         (forward-line -1)
         (indent-according-to-mode))
       (setq sp-escape-quotes-after-insert nil)
       (sp-local-pair 'c++-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
       (sp-local-pair 'c-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
       (sp-local-pair 'java-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
       (sp-local-pair 'web-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
       (sp-local-pair 'typescript-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
       (sp-local-pair 'js-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET"))))
   #+END_SRC

   Always indent using spaces.

   #+begin_src emacs-lisp
    (use-package emacs
      :config
      (setq-default tab-always-indent 'complete)
      (setq-default tab-width 4)
      (setq-default indent-tabs-mode nil))
   #+end_src
  
   Use =eldoc= for contextual information in the echo area.

   #+begin_src emacs-lisp
    (use-package eldoc
      :diminish
      :config
      (global-eldoc-mode 1))
   #+end_src

   Use UTF-8 encoding everywhere.

   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (set-language-environment "UTF-8")
       (set-default-coding-systems 'utf-8))
   #+end_src

   Delete trailing whitespace after saving in all modes except markdown-mode and org-mode.
   Markdown uses two trailing blanks to signal a line break.

   Source: [[https://github.com/munen/emacs.d/#delete-trailing-whitespace]]

   #+BEGIN_SRC emacs-lisp
     (use-package emacs
       :config
       (add-hook 'before-save-hook
                 '(lambda ()
                    (when (not (or (derived-mode-p 'markdown-mode)
                                   (derived-mode-p 'org-mode)))
                      (delete-trailing-whitespace)))))
   #+END_SRC

   Declare an interactive function to clean whitespace and indent the buffer.

   Source: https://github.com/wandersoncferreira/dotfiles/blob/min/emacs/conf.org#editing-mode

   #+BEGIN_SRC emacs-lisp
     (defun +normalize-buffer ()
       "Delete extra whitespace, tabs -> spaces, and indent buffer"
       (interactive)
       (delete-trailing-whitespace)
       (untabify (point-min) (point-max))
       (indent-region (point-min) (point-max)))
   #+END_SRC

** Diffs

   Source: [[https://gitlab.com/protesilaos/dotfiles/-/blob/master/emacs/.emacs.d/emacs-init.org][Prot's dotfiles]].

   #+begin_quote
   Overview of my preferences for how diffs should look:

   + Always start the buffer in a read-only state.  A typo will mess things
     up when trying to apply a patch.
   + After applying a diff hunk (=diff-apply-hunk= with =C-c C-a=) move on to
     the next one.
   + Update hunk headers automatically following an edit to the diff.
   + Do not show word-wise ("refined") changes upon activation.  I prefer
     to do so manually.  All such highlights are removed if you generate
     the buffer again (with =g= as expected) and the default is to not show
     word-wise changes.
   + Do not prettify headers.  I like the standard "patch" looks.  It also
     makes it easier to copy the diff elsewhere.

   + =prot-diff-buffer-dwim= will produce a diff that compares the current
     buffer to the last saved state of the underlying file.  If the buffer
     has no unsaved edits, the command will produce a diff that compares
     the file to its last registered version-controlled state.  Calling the
     command with an optional prefix argument (=C-u=) will enable word-wise
     highlighting across the diff.

   + =prot-diff-refine-dwim= is how I manually control word-wise diff
     highlights.  By default, the command will turn on refined changes
     throughout the buffer.  If called with an optional prefix argument, it
     will operate only on the diff hunk at point.  If the region is active,
     it will instead apply fontification to the diff hunks encompassed by
     the region.  And if word-wise highlights are already present, the
     command will remove everything and leave point back where it was.

   + =prot-diff-narrow-dwim= narrows to the diff hunk at point.  If narrowing
     is already present, it widens the buffer.  When invoked with an
     optional prefix argument, it narrows to the current file.

   + =C-c C-c= or =M-o= takes you to the point of the changes in the source
     file.  If you run this of the diff hunk's heading, you go to the
     beginning of the context.  But if you place the point somewhere inside
     of the diff's added changes or context, you will visit that exact
     position in the original file (does not work for removed text because
     technically it does not exist).

   + When working with patches to source code, which are distributed
     e.g. through email, you can apply the current hunk with =C-c C-a= or
     test for compatibility with =C-c C-t=.  This is a nice way to easily
     merge contributions from others, without having to go through the
     workflow of some proprietary Git/Version-Control forge.

   + With =M-n= and =M-p= you move between hunks.  With =M-}= and =M-{= or =M-N=, =M-P=
     do the same between files.
   #+end_quote

   #+begin_src emacs-lisp
     (use-package diff-mode
       :config
       (setq diff-default-read-only t)
       (setq diff-advance-after-apply-hunk t)
       (setq diff-update-on-the-fly t)
       ;; The following are from Emacs 27.1
       (setq diff-refine nil)                ; I do it on demand
       (setq diff-font-lock-prettify nil)    ; better for patches
       (setq diff-font-lock-syntax 'hunk-also))

     (use-package prot-diff
       :straight (:type built-in)
       ;; `prot-diff-buffer-dwim' replaces the default for `vc-diff' (which I
       ;; bind to another key---see VC section).
       :bind (("C-x v =" . prot-diff-buffer-dwim)
          :map diff-mode-map
          ("C-c C-b" . prot-diff-refine-dwim) ; replace `diff-refine-hunk'
          ("C-c C-n" . prot-diff-narrow-dwim)))
   #+end_src

** Magit

   Magit is the best git client.

   #+begin_src emacs-lisp
     (use-package magit
       :straight t
       :bind ("C-c g" . magit-status))
   #+end_src

   #+begin_src emacs-lisp
     (use-package git-commit
       :after magit
       :config
       (setq git-commit-summary-max-length 50)
       (setq git-commit-known-pseudo-headers
         '("Signed-off-by"
           "Acked-by"
           "Modified-by"
           "Cc"
           "Suggested-by"
           "Reported-by"
           "Tested-by"
           "Reviewed-by"))
       (setq git-commit-style-convention-checks
         '(non-empty-second-line
           overlong-summary-line)))
   #+end_src

   Only highlight changes within a line.

   #+begin_src emacs-lisp
     (use-package magit-diff
       :after magit
       :config
       (setq magit-diff-refine-hunk t))
   #+end_src
** Markdown

   #+begin_src emacs-lisp
     (use-package markdown-mode
       :straight t
       :config
       ;; Allows for fenced block focus with C-c ' (same as Org blocks).
       (use-package edit-indirect :straight t)
       (setq markdown-fontify-code-blocks-natively t)
       :mode ("\\.md$" . markdown-mode))
   #+end_src
** Linting

   Prefer =flymake= since it's built-in.
   
   #+begin_src emacs-lisp
     (use-package flymake
       :after prot-project
       :commands flymake-mode
       :init
       (setq flymake-fringe-indicator-position 'left-fringe)
       (setq flymake-suppress-zero-counters t)
       (setq flymake-start-on-flymake-mode t)
       (setq flymake-no-changes-timeout nil)
       (setq flymake-start-on-save-buffer t)
       (setq flymake-proc-compilation-prevents-syntax-check t)
       (setq flymake-wrap-around nil)
       :bind (:map flymake-mode-map
           ("C-c ! s" . flymake-start)
           ("C-c ! d" . flymake-show-diagnostics-buffer)
           ("C-c ! n" . flymake-goto-next-error)
           ("C-c ! p" . flymake-goto-prev-error)))

     (use-package flymake-diagnostic-at-point
       :straight t
       :after flymake
       :config
       (setq flymake-diagnostic-at-point-display-diagnostic-function
         'flymake-diagnostic-at-point-display-minibuffer))
   #+end_src

*** Proselint

    #+begin_src emacs-lisp
      (use-package flymake-proselint
    :straight t
    :after flymake
    :init
    (dolist (mode '("markdown-mode" "org-mode" "text-mode"))
      (add-hook (intern (concat mode "-hook")) #'flymake-proselint-setup)))
    #+end_src
    
*** Aspell

    #+begin_src emacs-lisp
  (use-package flymake-aspell
    :after (flyspell flymake)
    :straight t
    :init
    (dolist (mode '("markdown-mode" "org-mode" "text-mode"))
      (add-hook (intern (concat mode "-hook")) #'flymake-aspell-setup)))
    #+end_src

** Formatting
   
   =format-all= supports auto-formatting pretty much every language I use.
   
   Press =<f6>= to format the buffer.

   #+begin_src emacs-lisp
     (use-package format-all
       :straight t
       :config
       (define-key prog-mode-map (kbd "<f6>") 'format-all-buffer))
   #+end_src

** Nix
   
   Support editing Nix files.

   #+begin_src emacs-lisp
     (use-package nix-mode
       :straight t
       :defer t
       :mode "\\.nix\\'")
   #+end_src
   
   Use =direnv= to update the =$PATH=.

   #+begin_src emacs-lisp
     (use-package direnv
       :straight t
       :config
       (direnv-mode))
   #+end_src

** Languages
*** Python

    #+begin_src emacs-lisp
      (use-package elpy
        :straight t
        :after reformatter
        :defer t
        :init
        (elpy-enable)
        :config
        (when-let (ipython (executable-find "ipython"))
          (setq python-shell-interpreter ipython
                python-shell-interpreter-args "-i --simple-prompt")))
    #+end_src

*** Prolog

    Use Prolog mode on files with a .pl extension.

    #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.pl\\'" . prolog-mode))
    #+END_SRC

    Use SWI-Prolog as the interpreter.

    #+BEGIN_SRC emacs-lisp
      (setq prolog-system 'swi)

      (when (executable-find "swipl")
        (setq prolog-program-name `((swi ,(executable-find "swipl")) (t "pl"))))
    #+END_SRC
    
*** OCaml

    The combination of Merlin and Tuareg makes Emacs a fantastic editor for OCaml.

    #+BEGIN_SRC emacs-lisp
      (use-package tuareg
        :straight t
        :defer t
        :config
        (add-hook 'tuareg-mode-hook
                  (lambda()
                    (when (functionp 'prettify-symbols-mode)
                      (prettify-symbols-mode))))
        (add-hook 'tuareg-mode-hook #'(lambda() (setq mode-name "🐫"))))

      (use-package merlin
        :straight t
        :defer t
        :custom
        (merlin-command 'opam)
        (merlin-completion-with-doc t)
        (company-quickhelp-mode t)
        :bind (:map merlin-mode-map
                    ("M-." . merlin-locate)
                    ("M-," . merlin-pop-stack)
                    ("C-c C-o" . merlin-occurrences)
                    ("C-c C-j" . merlin-jump)
                    ("C-c i" . merlin-locate-ident)
                    ("C-c C-e" . merlin-iedit-occurrences))
        :hook
        (reason-mode . merlin-mode)
        (tuareg-mode . +ocaml-init-merlin-h)
        (caml-mode-hook . merlin-mode)
        :init
        (defun +ocaml-init-merlin-h ()
          "Activate `merlin-mode' if the ocamlmerlin executable exists."
          (when (executable-find "ocamlmerlin")
            (merlin-mode)))
        :config
        (add-hook 'reason-mode-hook (lambda ()
                                      (add-hook 'before-save-hook 'refmt-before-save)
                                      (merlin-mode)))
        ;; Make company aware of merlin
        (with-eval-after-load 'company
          (add-to-list 'company-backends 'merlin-company-backend)))

      (use-package flycheck-ocaml
        :straight t
        :defer t
        :hook (merlin-mode . +ocaml-init-flycheck-h)
        :config
        (defun +ocaml-init-flycheck-h ()
          "Activate `flycheck-ocaml`"
          ;; Disable Merlin's own error checking
          (setq merlin-error-after-save nil)
          ;; Enable Flycheck checker
          (flycheck-ocaml-setup)))

      (use-package merlin-eldoc
        :straight t
        :defer t
        :hook (merlin-mode . merlin-eldoc-setup))

      (use-package utop
        :straight t
        :defer t
        :hook (tuareg-mode . utop-minor-mode)
        :config
        (setq utop-command "opam config exec -- dune utop . -- -emacs"))

      ;; bootstrap ocamlformat with straight.el
      (straight-use-package
       '(ocamlformat :type git
                     :host github
                     :repo "ocaml-ppx/ocamlformat"
                     :files ("emacs/*.el")))

      (with-eval-after-load 'ocamlformat
        (progn
          ;; HACK set the correct ocamlformat executable
          (let ((ocamlformat-path
                 (concat (substring
                          (shell-command-to-string
                           "eval $(opam env) && echo $OPAM_SWITCH_PREFIX")
                          0 -1)
                         "/bin/ocamlformat")))
            (if (executable-find ocamlformat-path)
                (progn
                  ;; TODO set this
                  (setq ocamlformat-command "")
                  (add-hook 'tuareg-mode-hook
                            #'(lambda ()
                                (add-hook 'before-save-hook 'ocamlformat-before-save))))
              (message "Error: ocamlformat is not installed")))))

      (let ((opam-share (ignore-errors
                          (car (process-lines "opam" "config" "var" "share")))))
        (when (and opam-share (file-directory-p opam-share))
          (add-to-list 'load-path (expand-file-name "emacs/site-lisp" opam-share))
          (autoload 'merlin-mode "merlin" nil t nil)
          (add-hook 'tuareg-mode-hook 'merlin-mode t)
          (add-hook 'caml-mode-hook 'merlin-mode t)))
    #+END_SRC

* Org
** General settings 
   Enable spellchecking.

   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook 'flyspell-mode)
   #+end_src

   Set up refile targets.

   #+BEGIN_SRC emacs-lisp
     (setq org-refile-targets '((nil :maxlevel . 1)
                (org-agenda-files :maxlevel . 1)))
   #+END_SRC

   Always start in visual-line-mode (soft line wrapping).

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook 'visual-line-mode)
   #+END_SRC

** Task Management

   Store org files in Dropbox.

   #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/Dropbox/org/")
   #+END_SRC

   Setup the global TODO list.

   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-show-log t)
   #+END_SRC

   Record the time a TODO was archived.

   #+BEGIN_SRC emacs-lisp
     (setq org-log-done 'time)
   #+END_SRC

   Create functions to open my tasks and another to open my homework. Called with =M-x RET tasks RET= or =M-x RET homework RET=.

   Source: [[https://github.com/munen/emacs.d/#general-configuration]]

   #+BEGIN_SRC emacs-lisp
     (defun set-org-agenda-files ()
       "Set different org-files to be used in org-agenda"
       (setq org-agenda-files (list (concat org-directory "tasks.org")
                    (concat org-directory "refile-beorg.org")
                    (concat org-directory "homework.org"))))

     (set-org-agenda-files)

     (defun tasks ()
       "Open main tasks file and start 'org-agenda' for this week."
       (interactive)
       (find-file (concat org-directory "tasks.org"))
       (set-org-agenda-files)
       (org-agenda-list)
       (org-agenda-week-view)
       (shrink-window-if-larger-than-buffer)
       (other-window 1))

     (defun homework ()
       "Open homework file and start 'org-agenda' for this week."
       (interactive)
       (find-file (concat org-directory "homework.org"))
       (set-org-agenda-files)
       (org-agenda-list)
       (org-agenda-week-view)
       (shrink-window-if-larger-than-buffer)
       (other-window 1))
   #+END_SRC

** Exporting

   Change straight quotes to curly quotes when exporting.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-with-smart-quotes t)
   #+END_SRC

   Don’t include a footer with my contact and publishing information at the bottom of every exported HTML document.

   #+BEGIN_SRC emacs-lisp
     (setq org-html-postamble nil)
   #+END_SRC

   Set the Emacs browser to the default MacOS browser.

   #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'browse-url-default-macosx-browser)
   #+END_SRC

   Produce pdfs with syntax highlighting with =minted=.

   #+BEGIN_SRC emacs-lisp
     ;; (setq org-latex-pdf-process
     ;;       '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     ;;         "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     ;;         "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
     (setq org-latex-pdf-process '("xelatex -shell-escape %f" "biber %b" "xelatex -shell-escape %f" "xelatex -shell-escape %f"))
     (setq bibtex-dialect 'biblatex)
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     (setq org-latex-listings 'minted)
   #+END_SRC
